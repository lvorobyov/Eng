Общие концепции программирования: написание и отладка программ
==============================================================
AT&T, Второе издание, 1999

Источник: https://web.archive.org/web/20060519053802/http://davinci01.man.ac.uk/aix433/aixprggd/genprogc/writing_reentrant_thread_safe_code.htm

== Написание реентерабельного и потокобезопасного кода

В <<st,однопоточных>> программах есть только один <<cf,поток управления>>. Так что код таких программ не обязан быть <<re,реентерабельным>> или <<ts.потокобезопасным>>. В <<mt,многопоточных>> программах несколько потоков управления могут одновременно выполнять одну и ту же подпрограмму и получать доступ к одним и тем же данным. Для защиты этих данных код многопоточной программы должен быть реентерабельным и потокобезопасным.

Глава повествует о написании реентерабельных и потокобезопасных программ. Она не освещает тему эффективности распараллеливания программ, это достигается лишь на этапе проектирования программы. Для того. чтобы распараллелить существующие однопоточные программы из нужно полностью перепроектировать и переписать.

=== Определение реентерабельности и потокобезопасности

И реентерабельность и потокобезопасность связаны со способом управления ресурсами функцией. Реентерабельность и потокобезопасность - это разные понятия: функция может быть либо реентерабельной, либо потокобезопасной, либо ни той, ни другой.

==== Реентерабельность

Реентерабельная функция не удерживает статические данные между последовательными вызовами и не возвращает указатель на статические данные. Все данные предоставляются вызывающей функцией. Реентерабельная функция не должна вызывать нереентерабельные функции.

Нереентерабельная функция часто, но не всегда, может быть выявлена по внешнему интерфейсу и использованию. Например, подпрограмма strtok не является реентерабельной, поскольку она содержит строку для разбиения на токены. Подпрограмма ctime также не является реентерабельной; она возвращает указатель на статические данные, которые перезаписываются при каждом вызове.

==== Безопасность потоков

Безопасная в смысле потоков функция защищает общие ресурсы от одновременного доступа блокировками. Потокобезопасность касается только реализации функции и не влияет на её внешний интерфейс.

В C локальные переменные динамически располагаются в стеке. Поэтому любая функция, которая не использует статические данные или другие общие ресурсы, является тривиально потокобезопасной. Например, следующая функция является потокобезопасной:

----
/* потокобезопасная функция */
int diff(int x, int y)
{
        int delta;
 
        delta = y - x;
        if (delta < 0)
                delta = -delta;
 
        return delta;
}
----

Использование глобальных данных небезопасно для потоков. Каждый поток должен содержать собственные данные или инкапсулировать их твк, чтобы доступ к ним был последовательный. Поток может прочитать код ошибки, соответствующий ошибке, произошедшей в другом потоке. В AIX каждый поток имеет своё собственное значение errno.

=== Делаем функцию реентерабольной

В большинстве случаев нереентерабельные функции должны быть заменены функциями с измененным интерфейсом, чтобы стать реентерабельными. Нереентерабельные функции не могут использоваться несколькими потоками. Кроме того, может оказаться невозможным сделать нереентерабельную функцию потокобезопасной.

==== Возвращаемое значение

Большинство нереентерабельных функций возвращают указатель на статические данные. Этого можно избежать двумя способами:

- Возврат динамически выделенных данных. В этом случае ответственность за освобождение памяти лежит на вызывающей функции. Преимущество заключается в том, что интерфейс не нуждается в изменении. Однако обратная совместимость не обеспечивается; существующие однопоточные программы, использующие модифицированные функции без изменений, не освобождают память, что приводит к утечкам памяти.
- Использование хранилища, предоставляемого вызывающей функцией. Этот метод рекомендуется, хотя интерфейс должен быть изменён.

Например, функция strtoupper, преобразующая строку в верхний регистр, может быть реализована как в следующем фрагменте кода:

----
/* нереентерабельная функция */
char *strtoupper(char *string)
{
        static char buffer[MAX_STRING_SIZE];
        int index;
 
        for (index = 0; string[index]; index++)
                buffer[index] = toupper(string[index]);
        buffer[index] = 0
 
        return buffer;
}
----

Эта функция не является реентерабельной (и потокобезопасной). Используя первый метод, чтобы сделать функцию реентерабельной, функция станет похожа на следующий фрагмент кода:

----
/* реентерабельная функция (плохое решение) */
char *strtoupper(char *string)
{
        char *buffer;
        int index;
 
        /* необходимо выполнить проверку ошибок! */
        buffer = malloc(MAX_STRING_SIZE);
 
        for (index = 0; string[index]; index++)
                buffer[index] = toupper(string[index]);
        buffer[index] = 0
 
        return buffer;
}
----

Лучшее решение состоит в изменении интерфейса. Вызывающий объект должен обеспечить хранение как входных, так и выходных строк, как показано в следующем фрагменте кода:

----
/* реентерабельная функция (лучшее решение) */
char *strtoupper_r(char *in_str, char *out_str)
{
        int index;
 
        for (index = 0; in_str[index]; index++)
        out_str[index] = toupper(in_str[index]);
        out_str[index] = 0
 
        return out_str;
}
----

Нереентерабельные стандартные подпрограммы библиотеки C были сделаны реентерабельными с помощью второго метода. Это обсуждается ниже.



include::glossary.adoc[]
