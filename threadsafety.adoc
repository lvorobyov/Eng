Общие концепции программирования: написание и отладка программ
==============================================================
AT&T, Второе издание, 1999

Источник: https://web.archive.org/web/20060519053802/http://davinci01.man.ac.uk/aix433/aixprggd/genprogc/writing_reentrant_thread_safe_code.htm

== Написание реентерабельного и потокобезопасного кода

В <<st,однопоточных>> программах есть только один <<cf,поток управления>>. Так что код таких программ не обязан быть <<re,реентерабельным>> или <<ts.потокобезопасным>>. В <<mt,многопоточных>> программах несколько потоков управления могут одновременно выполнять одну и ту же подпрограмму и получать доступ к одним и тем же данным cite:[threadsafety]. Для защиты этих данных код многопоточной программы должен быть реентерабельным и потокобезопасным.

Глава повествует о написании реентерабельных и потокобезопасных программ. Она не освещает тему эффективности распараллеливания программ, это достигается лишь на этапе проектирования программы. Для того. чтобы распараллелить существующие однопоточные программы из нужно полностью перепроектировать и переписать.

=== Определение реентерабельности и потокобезопасности

И реентерабельность и потокобезопасность связаны со способом управления ресурсами функцией. Реентерабельность и потокобезопасность - это разные понятия: функция может быть либо реентерабельной, либо потокобезопасной, либо ни той, ни другой.

==== Реентерабельность

Реентерабельная функция не удерживает статические данные между последовательными вызовами и не возвращает указатель на статические данные. Все данные предоставляются вызывающей функцией. Реентерабельная функция не должна вызывать нереентерабельные функции.

Нереентерабельная функция часто, но не всегда, может быть выявлена по внешнему интерфейсу и использованию. Например, подпрограмма strtok не является реентерабельной, поскольку она содержит строку для разбиения на токены. Подпрограмма ctime также не является реентерабельной; она возвращает указатель на статические данные, которые перезаписываются при каждом вызове.

==== Безопасность потоков

Безопасная в смысле потоков функция защищает общие ресурсы от одновременного доступа блокировками. Потокобезопасность касается только реализации функции и не влияет на её внешний интерфейс.

В C локальные переменные динамически располагаются в стеке. Поэтому любая функция, которая не использует статические данные или другие общие ресурсы, является тривиально потокобезопасной. Например, следующая функция является потокобезопасной:

----
/* потокобезопасная функция */
int diff(int x, int y)
{
        int delta;
 
        delta = y - x;
        if (delta < 0)
                delta = -delta;
 
        return delta;
}
----

Использование глобальных данных небезопасно для потоков. Каждый поток должен содержать собственные данные или инкапсулировать их твк, чтобы доступ к ним был последовательный. Поток может прочитать код ошибки, соответствующий ошибке, произошедшей в другом потоке. В AIX каждый поток имеет своё собственное значение errno.

=== Делаем функцию реентерабольной

В большинстве случаев нереентерабельные функции должны быть заменены функциями с измененным интерфейсом, чтобы стать реентерабельными. Нереентерабельные функции не могут использоваться несколькими потоками. Кроме того, может оказаться невозможным сделать нереентерабельную функцию потокобезопасной.

==== Возвращаемое значение

Большинство нереентерабельных функций возвращают указатель на статические данные. Этого можно избежать двумя способами:

- Возврат динамически выделенных данных. В этом случае ответственность за освобождение памяти лежит на вызывающей функции. Преимущество заключается в том, что интерфейс не нуждается в изменении. Однако обратная совместимость не обеспечивается; существующие однопоточные программы, использующие модифицированные функции без изменений, не освобождают память, что приводит к утечкам памяти.
- Использование хранилища, предоставляемого вызывающей функцией. Этот метод рекомендуется, хотя интерфейс должен быть изменён.

Например, функция strtoupper, преобразующая строку в верхний регистр, может быть реализована как в следующем фрагменте кода:

----
/* нереентерабельная функция */
char *strtoupper(char *string)
{
        static char buffer[MAX_STRING_SIZE];
        int index;
 
        for (index = 0; string[index]; index++)
                buffer[index] = toupper(string[index]);
        buffer[index] = 0
 
        return buffer;
}
----

Эта функция не является реентерабельной (и потокобезопасной). Используя первый метод, чтобы сделать функцию реентерабельной, функция станет похожа на следующий фрагмент кода:

----
/* реентерабельная функция (плохое решение) */
char *strtoupper(char *string)
{
        char *buffer;
        int index;
 
        /* необходимо выполнить проверку ошибок! */
        buffer = malloc(MAX_STRING_SIZE);
 
        for (index = 0; string[index]; index++)
                buffer[index] = toupper(string[index]);
        buffer[index] = 0
 
        return buffer;
}
----

Лучшее решение состоит в изменении интерфейса. Вызывающий объект должен обеспечить хранение как входных, так и выходных строк, как показано в следующем фрагменте кода:

----
/* реентерабельная функция (лучшее решение) */
char *strtoupper_r(char *in_str, char *out_str)
{
        int index;
 
        for (index = 0; in_str[index]; index++)
        out_str[index] = toupper(in_str[index]);
        out_str[index] = 0
 
        return out_str;
}
----

Нереентерабельные стандартные подпрограммы библиотеки C были сделаны реентерабельными вторым способом. Это обсуждается ниже.

==== Хранение данных между последовательными вызовами

Никакие данные не должны храниться между последовательными вызовами, поскольку различные потоки могут последовательно вызывать функцию. Если функция должна хранить некоторые данные между последовательными вызовами, такие как рабочий буфер или указатель, эти данные должны быть предоставлены вызывающей функцией.

Рассмотрим следующий пример. Функция возвращает последовательные символы нижнего регистра строки. Строка предоставляется только при первом вызове, как и в случае с подпрограммой strtok. Функция возвращает 0, когда она достигает конца строки. Эта функция может быть реализована как в следующем фрагменте кода:

----
/* нереентерабельная функция */
char lowercase_c(char *string)
{
        static char *buffer;
        static int index;
        char c = 0;
 
        /* сохраняет строку при первом вызове */
        if (string != NULL) {
                buffer = string;
                index = 0;
        }
 
        /* поиск строчного символа */
        for (; c = buffer[index]; index++) {
                if (islower(c)) {
                        index++;
                        break;
                }
        }
        return c;
}
----

Эта функция не реентерабельна. Чтобы сделать её реентерабельной, статические данные, индексная переменная, должны храниться вызывающей функцией. Реентерабельная версия функции может быть реализована как в следующем фрагменте кода:

----
/* реентерабельная функция */
char reentrant_lowercase_c(char *string, int *p_index)
{
        char c = 0;
 
        /* никакой инициализации - вызывающая функция должна была это сделать */
 
        /* поиск строчного символа */
        for (; c = string[*p_index]; (*p_index)++) {
                if (islower(c)) {
                        (*p_index)++;
                        break;
                  }
        }
        return c;
}
----

Интерфейс функции изменился, как и ее использование. Вызывающая функция должна предоставить строку при каждом вызове и инициализировать индекс нулём перед первым вызовом, как в следующем фрагменте кода:

----
char *my_string;
char my_char;
int my_index;
...
my_index = 0;
while (my_char = reentrant_lowercase_c(my_string, &my_index)) {
        ...
}
----

=== Создание потокобезопасной функции

В многопоточных программах все функции, вызываемые несколькими потоками, должны быть потокобезопасными. Однако существует обходной путь для использования потоково небезопасных подпрограмм в многопоточных программах. Обратите внимание также, что нереентерабельные функции обычно являются непотокобезопасными, но их реентерабельность часто делает их также потокобезопасными.

==== Блокировка разделяемых данных

Функции, использующие статические данные или любые другие общие ресурсы, такие как файлы или терминалы, должны упорядочить доступ к этим ресурсам с помощью блокировок, чтобы быть потокобезопасными. Например, следующая функция является непотокобезопасной:

----
/* непотокобезопасная функция */
int increment_counter()
{
        static int counter = 0;
 
        counter++;
        return counter;
}
----

Чтобы стыть потокобезопасным, статическая переменная счётчика должен быть защищена статической блокировкой, как в следующем примере (псевдокод):

----
/* псевдокод потокобезопасной функции */
int increment_counter();
{
        static int counter = 0;
        static lock_type counter_lock = LOCK_INITIALIZER;
 
        lock(counter_lock);
        counter++;
        unlock(counter_lock);
        return counter;
}
----

В многопоточной прикладной программе, использующей библиотеку потоков, для упорядочения доступа к общим ресурсам должны использоваться мьютексы. Независимые библиотеки могут работать вне контекста потоков и, таким образом, использовать другие виды блокировок.

=== Обходной путь для непотокобезопасных функций

Можно вызывать непотокобезопасные функции в нескольких потоках используя обходной путь. Это может быть полезно, особенно при использовании непотокобезопасной библиотеки в многопоточной программе, для тестирования или в ожидании выхода потокобезопасной версии библиотеки. Обходной путь приводит к некоторым накладным расходам, поскольку он состоит из упорядочивании вызрва всей функции или даже группы функций.

- Используйте глобальную блокировку для библиотеки и блокируйте ее каждый раз, когда вы используете библиотеку (вызывая библиотечную процедуру или используя глобальную переменную библиотеки), как в следующих фрагментах псевдокода:

----
/* это псевдокод! */
 
lock(library_lock);
library_call();
unlock(library_lock);
 
lock(library_lock);
x = library_var;
unlock(library_lock);
----

Это решение может создать узкие места производительности, поскольку только один поток может получить доступ к любой части библиотеки в один момент времени. Это решение приемлемо только в том случае, если доступ к библиотеке осуществляется редко или в качестве начального, быстро реализуемого обходного пути.

- Используйте блокировку для каждого компонента библиотеки (подпрограмма или глобальная переменная) или группы компонентов, как в следующих фрагментах псевдокода:

----
/* это псевдокод! */
 
lock(library_moduleA_lock);
library_moduleA_call();
unlock(library_moduleA_lock);
 
lock(library_moduleB_lock);
x = library_moduleB_var;
unlock(library_moduleB_lock);
----

Это решение несколько сложнее в реализации, чем первое, но оно может повысить производительность.

Поскольку этот обходной путь должен использоваться только в прикладных программах, а не в библиотеках, для блокировки библиотеки могут использоваться мьютексы.

=== Реентерабельные и потокобезопасные библиотеки

Реентерабельные и потокобезопасные библиотеки полезны в широком диапазоне параллельных (и асинхронных) сред программирования, а не только в потоках. Таким образом, хорошая практика программирования - всегда использовать и писать реентерабельные и потокобезопасные функции.

==== Использование библиотеки

Некоторые библиотеки, поставляемые с базовой операционной системой AIX, являются потокобезопасными. В текущей версии (1999 год) AIX потокобезопасными являются следующие библиотеки:

- Стандартная библиотека языка С (libc.a)
- Библиотека совместимости Беркли (libbsd.a).

Некоторые из стандартных подпрограмм языка C не являются реентерабельными, например подпрограммы time и strtok. Реентерабельная версия подпрограмм имеет имя исходной подпрограммы с суффиксом _r (подчеркивание).

При написании многопоточных программ вместо исходной версии следует использовать реентерабельные версии подпрограмм. Например, следующий фрагмент кода:

----
token[0] = strtok(string, separators);
i = 0;
do {
        i++;
        token[i] = strtok(NULL, separators);
} while (token[i] != NULL);
----

следует заменить в многопоточной программе следующим фрагментом кода:

----
char *pointer;
...
token[0] = strtok_r(string, separators, &pointer);
i = 0;
do {
        i++;
        token[i] = strtok_r(NULL, separators, &pointer);
} while (token[i] != NULL);
----

Небезопасные для потоков библиотеки могут использоваться только одним потоком в программе. Уникальность потока, использующего библиотеку, должна быть обеспечена программистом; в противном случае программа будет иметь неожиданное поведение или даже может произойти сбой.

==== Преобразование библиотек

Эта информация освещает основные шаги по преобразованию существующей библиотеки в реентерабельную и потокобезопасную библиотеку. Это относится только к библиотекам языка Си.

- Идентификация экспортированных глобальных переменных. Эти переменные обычно определяются в заголовочном файле с ключевым словом export.
- Экспортируемые глобальные переменные должны быть инкапсулированы. Переменная должна быть закрыта (определена с помощью ключевого слова static в исходном коде библиотеки). Должны быть созданы подпрограммы доступа (чтение и запись).
Определение статических переменных и других общих ресурсов. Статические переменные обычно определяются с помощью ключевого слова static.
- Блокировки должны быть связаны с любым общим ресурсом. Детализация блокировки, таким образом, выбор количества блокировок, влияет на производительность библиотеки. Для инициализации блокировок можно использовать средство одноразовой инициализации.
- Выявление нереентерабельных функций и превращение их в реентерабельные.
- Идентификация непотокобезопасных функций и обеспечение их потокобезопасности.

include::glossary.adoc[]
